(window.webpackJsonp=window.webpackJsonp||[]).push([[201],{254:function(t,a,e){"use strict";e.r(a);var v=e(0),i=Object(v.a)({},function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"http协议"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http协议","aria-hidden":"true"}},[t._v("#")]),t._v(" http协议")]),t._v(" "),e("ol",[e("li",[t._v("HTTP有哪些方法？")]),t._v(" "),e("li",[t._v("http的请求报文和响应是什么样的？")]),t._v(" "),e("li",[t._v("HTTP的部首有哪些")]),t._v(" "),e("li",[t._v("HTTP的状态码")]),t._v(" "),e("li",[t._v("HTTPS是如何保证安全的？https 的握手过程")]),t._v(" "),e("li",[t._v("什么是CA证书？整个网站进行验证的流程是什么？")]),t._v(" "),e("li",[t._v("http各个版本的区别是什么？解决了哪些问题？")]),t._v(" "),e("li",[t._v("tcp/ip协议的三次握手，四次挥手")]),t._v(" "),e("li",[t._v("缓存策略")])]),t._v(" "),e("h2",{attrs:{id:"http版本发展史："}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http版本发展史：","aria-hidden":"true"}},[t._v("#")]),t._v(" http版本发展史：")]),t._v(" "),e("p",[t._v("版本路线如下：\nHTTP/0.9： 协议诞生自 1989 年，第一版本是 HTTP 0.9，但 HTTP 0.9 并不是一个正式标准。\nHTTP/1.0： 1996 年，根据 RFC 1945，HTTP 1.0 成为 IEFT 标准，\nHTTP/1.1： 1999 年，在 RFC 2616 中发布了 HTTP 1.1。\nHTTP/2：   HTTP 2.0 于 2015 年发布")]),t._v(" "),e("h3",{attrs:{id:"http-1-0-时代最重要的两个大问题："}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-1-0-时代最重要的两个大问题：","aria-hidden":"true"}},[t._v("#")]),t._v(" HTTP 1.0 时代最重要的两个大问题：")]),t._v(" "),e("ol",[e("li",[t._v("TCP 连接无法复用，每次请求都需要重新建立 TCP 通道，也就要重复三次握手和四次挥手的情况；就是说每个 TCP 连接只能发送一个请求。")]),t._v(" "),e("li",[t._v("队头阻塞，每个请求都要过“独木桥”，桥宽为一个请求的宽度；也就是说，即使多个请求并行发出，也只能一个接一个地进行请求排队。")])]),t._v(" "),e("h3",{attrs:{id:"http-1-1-的改进点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-1-1-的改进点","aria-hidden":"true"}},[t._v("#")]),t._v(" HTTP 1.1 的改进点")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("长连接：HTTP 1.1 支持长连接（Persistent Connection），且默认就开启了 Connection：keep-alive，这样在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。")])]),t._v(" "),e("li",[e("p",[t._v("管线化（Http Pipelining）: 使得多个请求使用同一个 tcp 连接使请求并按照并行方式成为可能：多个请求同时发起，无需等待上一个请求的回包。但是需要注意，管线化只是让请求并行，但并没有从根本上解决队头阻塞问题，因为响应仍然要遵循先进先出的原则，第一个请求的回包发出之后，才会响应第二个请求。同时，浏览器供应商很难实现管道，而且大多数浏览器默认禁用该特性，有的甚至完全删除了它。")])])]),t._v(" "),e("h3",{attrs:{id:"http-1-1-的不足"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-1-1-的不足","aria-hidden":"true"}},[t._v("#")]),t._v(" HTTP 1.1 的不足")]),t._v(" "),e("ul",[e("li",[t._v("队头堵塞问题没有真正解决")]),t._v(" "),e("li",[t._v("明文传输，安全性有隐患")]),t._v(" "),e("li",[t._v("header 携带内容过多，增加了传输成本")]),t._v(" "),e("li",[t._v("默认开启 keep-alive 可能会给服务端造成更大的性能压力，比如对于一次性的请求（图片 CDN 服务），在文件被请求之后还保持了不必要的连接很长时间")])]),t._v(" "),e("h3",{attrs:{id:"http-2的特性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-2的特性","aria-hidden":"true"}},[t._v("#")]),t._v(" HTTP/2的特性")]),t._v(" "),e("ol",[e("li",[t._v("http2相关概念\n帧：HTTP 2.0 中，客户端与服务器通过交换帧来通信，帧是基于这个新协议通信的最小单位。\n消息：是指逻辑上的 HTTP 消息，比如请求、响应等，由一或多个帧组成。\n流：流是连接中的一个虚拟信道，可以承载双向的消息；每个流都有一个唯一的标识符")])]),t._v(" "),e("h2",{attrs:{id:"图解http"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#图解http","aria-hidden":"true"}},[t._v("#")]),t._v(" 图解http")]),t._v(" "),e("p",[t._v("HTTP+ 加密 + 认证 + 完整性保护 =HTTPS")])])},[],!1,null,null,null);a.default=i.exports}}]);